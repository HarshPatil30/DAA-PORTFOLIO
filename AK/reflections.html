<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Algorithm Concepts</title>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;600&display=swap" rel="stylesheet">
  <style>
    * { 
      margin: 0; 
      padding: 0;
      box-sizing: border-box; 
    }
    :root { 
      --bg-primary: #0a0f1c; 
      --bg-secondary: #151f32; 
      --accent: #94a3b8; 
      --text-primary: #f8fafc;
      --text-secondary: #cbd5e1; 
      --highlight: #38bdf8; 
      --card-shadow: 0 4px 20px rgba(0, 0, 0, 0.2); 
    }
    @property --gradient-angle {
      syntax: '<angle>';
      initial-value: 0deg; 
      inherits: false; 
    }
    body { 
      font-family: 'Space Grotesk', sans-serif; 
      background-color: var(--bg-primary); 
      color: var(--text-primary);
      line-height: 1.6; 
      overflow-x: hidden; 
      perspective: 1000px;
    }
    .container {
      max-width: 1200px; 
      margin: 0 auto; 
      padding: 0 2rem; 
    }
    .header { 
      height: 100vh; 
      display: flex; 
      align-items: center; 
      position: relative; 
      overflow: hidden;
      justify-content: center; 
    }
    .header::before {
      content: ''; 
      position: absolute;
      inset: 0; 
      background: radial-gradient(circle at 50% 50%, rgba(56, 189, 248, 0.1), transparent); 
      opacity: 0; 
      animation: pulseGradient 8s ease-in-out infinite; 
    }
    .header-content { 
      position: relative; 
      z-index: 1; 
      opacity: 0; 
      transform: translateY(30px) rotateX(10deg);
      animation: heroEntrance 1.5s cubic-bezier(0.2, 0.8, 0.2, 1) forwards; 
      text-align: center; 
    }
    .title { 
      font-size: clamp(2.5rem, 5vw, 4.5rem); 
      font-weight: 600; 
      margin-bottom: 1rem; 
      line-height: 1.2;
      background: linear-gradient(var(--gradient-angle), var(--highlight), var(--text-primary)); 
      -webkit-background-clip: text; 
      background-clip: text; 
      color: transparent; 
      animation: rotateGradient 10s linear infinite;
    }
    .subtitle { 
      font-size: clamp(1rem, 2vw, 1.25rem); 
      color: var(--accent); 
      max-width: 600px; 
      margin-bottom: 2rem;
      opacity: 0; 
      transform: translateY(20px); 
      animation: fadeSlideUp 0.8s ease forwards 0.5s; 
    }
    .section { 
      padding: 3rem; 
      margin-bottom: 2rem;
      background-color: var(--bg-secondary); 
      border-radius: 12px; 
      box-shadow: var(--card-shadow); 
      opacity: 0; 
      transform: translateY(30px);
      transition: all 0.8s cubic-bezier(0.2, 0.8, 0.2, 1);
    }
    .section.visible {
      opacity: 1; 
      transform: translateY(0); 
    }
    .section-title {
      font-size: 2rem;
      margin-bottom: 1.5rem;
      position: relative; 
      display: inline-block;
      color: var(--highlight); 
    }
    .section-title::after {
      content: ''; 
      position: absolute;
      bottom: -10px; 
      left: 0; 
      width: 100%; 
      height: 2px; 
      background: linear-gradient(90deg, transparent, var(--highlight), transparent); 
      transform: scaleX(0); 
      transform-origin: center;
      animation: expandLine 0.6s ease forwards 0.5s; 
    }
    .card-content {
      font-size: 1rem;
      color: var(--text-secondary);
    }
    .card-content ul {
      list-style-type: none;
      padding-left: 20px;
    }
    .card-content li {
      margin-bottom: 10px;
    }
    .card-content li::before {
      content: "▫ ";
      color: var(--highlight);
    }
    
    @keyframes pulseGradient { 
      0%, 100% { opacity: 0.1; } 
      50% { opacity: 0.2; } 
    }
    @keyframes rotateGradient { 
      0% { background-position: 0%; }
      100% { background-position: 100%; }
    }
    @keyframes heroEntrance {
      to { 
        opacity: 1; 
        transform: translateY(0) rotateX(0); 
      }
    }
    @keyframes fadeSlideUp {
      to {
        opacity: 1;
        transform: translateY(0); 
      }
    }
    @keyframes expandLine {
      to {
        transform: scaleX(1); 
      }
    }
  </style>
</head>
<body>
  <div class="header">
    <div class="header-content">
      <h1 class="title">Learning Outcomes</h1>
    </div>
  </div>

  <div class="container">
    <section class="section visible">
      <h2 class="section-title"> Design Philosophy and Intuitions</h2>
      <div class="card-content">
        <ul>
          <li><strong>Design Philosophy:</strong> Rooted in problem-solving and efficient solutions. Break down problems into subproblems, evaluate trade-offs, and select appropriate techniques (greedy algorithms, dynamic programming, divide-and-conquer).</li>
          <li><strong>Algorithm Design Intuition:</strong> Recognize problem patterns (recursion, iteration), leverage known data structures.</li>
        </ul>
      </div>
    </section>

    <section class="section visible">
       <div class="card-content">
      <h2 class="section-title">Analyze Space and Time Complexities</h2>
             <ul>
          <li><strong>Time Complexity:</strong> Measures the runtime based on input size, expressed in Big O notation (O(n), O(log n)).</li>
          <li><strong>Space Complexity:</strong> Memory usage relative to input size, also in Big O notation.</li>
          <li><strong>Performance Analysis:</strong> Ensure scalability and efficiency, especially for large inputs.</li>
      <h2 class="section-title">Order of an Algorithm</h2>
                <li>Rate of increase in running time as input size increases. Common orders: O(1), O(log n), O(n), O(n²), O(2^n), etc.</li>
        </ul>
      </div>
    </section>

    <section class="section visible">
      <div class="card-content">
      <h2 class="section-title">Recursion, Iteration, Backtracking</h2>
        <ul>
          <li><strong>Recursion:</strong> Solves problems by solving smaller instances of the same problem.</li>
          <li><strong>Iteration:</strong> Repeats a set of operations over data.</li>
          <li><strong>Backtracking:</strong> Refines brute-force methods by trying all solutions and backtracking when a solution is not feasible.</li>
        </ul>
      </div>
    </section>

    <section class="section visible">
      <div class="card-content">
      <h2 class="section-title">Efficiency Analysis</h2>
              <ul>
          <li>Determine time and space complexity to understand scaling performance.</li>
         <h2 class="section-title">Hashing</h2>
                        <li>Maps data to a fixed-size value (hash code) for fast data retrieval, widely used in search operations and data storage.</li>
        </ul>
      </div>
    </section>

    <section class="section visible">
      <div class="card-content">
      <h2 class="section-title">Graphs, Trees</h2>
              <ul>
          <li><strong>Graphs:</strong> Collection of nodes (vertices) and edges, used to model networks.</li>
          <li><strong>Trees:</strong> Acyclic graphs with hierarchical structure, used in hierarchical data structures like file systems.</li>
        </ul>
      <h2 class="section-title">Tree Traversals, BST</h2>
              <ul>
          <li><strong>Tree Traversals:</strong> In-order (Left, root, right), Pre-order (Root, left, right), Post-order (Left, right, root).</li>
          <li><strong>Binary Search Trees (BST):</strong> Binary trees where the left child is smaller and the right child is larger than the parent node.</li>
        </ul>
            <h2 class="section-title">AVL Trees</h2>
              <ul>
          <li><strong>AVL Trees:</strong> Self-balancing binary search tree with height-balanced subtrees.</li>
        </ul>
            <h2 class="section-title">2-3 Trees</h2>
             <ul>
          <li><strong>2-3 Trees:</strong> Balanced search tree where nodes have 2 or 3 children, ensuring equal path lengths from root to leaf.</li>
        </ul>
           <h2 class="section-title">Tries, Segment Trees, Skip Lists</h2>
        <ul>
          <li><strong>Tries:</strong> Tree-like structure for storing strings efficiently.</li>
          <li><strong>Segment Trees:</strong> Efficient range queries and updates.</li>
          <li><strong>Skip Lists:</strong> Probabilistic data structure for fast search operations.</li>
        </ul>
      <h2 class="section-title"> Heaps</h2>
            <ul>
          <li><strong>Heaps:</strong> Binary tree-based structure for priority queues.</li>
        </ul>
            <h2 class="section-title"> Array Query, Sparse Tables</h2>
              <ul>
          <li><strong>Array Queries:</strong> Techniques for quick information retrieval from arrays.</li>
          <li><strong>Sparse Tables:</strong> Fast range queries with immutable data.</li>
        </ul>
            <h2 class="section-title"> Red-Black Trees</h2>
        <ul>
          <li><strong>Red-Black Trees:</strong> Balanced binary search tree with colored nodes for maintaining balance.</li>
        </ul>
            <h2 class="section-title"> Fenwick Trees</h2>
             <ul>
          <li><strong>Fenwick Trees:</strong> Efficient calculation of prefix sums and updates.</li>
        </ul>
            <h2 class="section-title"> DFS and BFS</h2>
              <ul>
          <li><strong>DFS (Depth-First Search):</strong> Graph traversal exploring as far as possible along each branch before backtracking.</li>
          <li><strong>BFS (Breadth-First Search):</strong> Graph traversal exploring nodes level by level.</li>
        </ul>
      </div>
    </section>
    
    <section class="section visible">
      <h2 class="section-title"> Sorting and Searching</h2>
      <div class="card-content">
        <ul>
          <li><strong>Bubble Sort:</strong> Compares and swaps adjacent elements repeatedly.</li>
          <li><strong>Selection Sort:</strong> Repeatedly selects and swaps the smallest/largest element.</li>
          <li><strong>Insertion Sort:</strong> Builds sorted portion one element at a time.</li>
          <li><strong>Merge Sort:</strong> Divides array, sorts recursively, and merges sorted halves.</li>
          <li><strong>Quick Sort:</strong> Divides array using a pivot, sorts subarrays recursively.</li>
          <li><strong>Heap Sort:</strong> Uses heap structure to sort by building a heap and extracting elements.</li>
        </ul>
      </div>
    </section>
    
    <section class="section visible">
      <div class="card-content">
      <h2 class="section-title">Brute Force String Search, Boyer-Moore Algorithm</h2>
              <ul>
          <li><strong>Brute Force:</strong> Checks all positions for the pattern in the text.</li>
          <li><strong>Boyer-Moore:</strong> Efficient string search using mismatches and heuristics.</li>
        </ul>
            <h2 class="section-title"> KMP Algorithm</h2>
              <ul>
          <li><strong>KMP:</strong> Uses partial match table for efficient string matching.</li>
        </ul>
            <h2 class="section-title"> Rabin Karp Algorithm</h2>
              <ul>
          <li><strong>Rabin Karp:</strong> Uses hashing for string matching, effective for multiple patterns.</li>
        </ul>
      </div>
    </section>

    <section class="section visible">
      <div class="card-content">
      <h2 class="section-title"> Graph Algorithms</h2>
              <ul>
          <li><strong>Floyd-Warshall Algorithm:</strong> Finds shortest paths between all pairs of vertices in a graph.</li>
        </ul>
            <h2 class="section-title"> Shortest Path Algorithms</h2>
              <ul>
          <li><strong>Dijkstra’s:</strong> Finds shortest path from source to all other nodes in a graph with non-negative edges.</li>
          <li><strong>Bellman-Ford:</strong> Finds shortest paths from source to all nodes, handling negative edges.</li>
        </ul>
            <h2 class="section-title"> Minimum Spanning Tree Algorithms</h2>
      <div class="card-content">
        <ul>
          <li><strong>Prim’s:</strong> Finds MST by adding the smallest edge without forming a cycle.</li>
          <li><strong>Kruskal’s:</strong> Finds MST by adding smallest edges and ensuring no cycles.</li>
        </ul>
      </div>
    </section>

    <section class="section visible">
      <div class="card-content">
      <h2 class="section-title"> Travelling Salesperson Problem</h2>
              <ul>
          <li><strong>Travelling Salesperson Problem:</strong> Optimization problem finding shortest route visiting all cities and returning to origin.</li>
        </ul>
      
      <h2 class="section-title"> Knapsack Problem</h2>
              <ul>
          <li><strong>Knapsack Problem:</strong> Select items to maximize value without exceeding weight limit. 0/1 Knapsack: Items are either included or excluded. Fractional Knapsack: Items can be divided to maximize value-to-weight ratio.</li>
        </ul>
     
      <h2 class="section-title"> Strassen’s Matrix Multiplication</h2>
     
        <ul>
          <li><strong>Strassen’s Matrix Multiplication:</strong> Optimized matrix multiplication reducing multiplicative operations.</li>
        </ul>
      
      <h2 class="section-title"> Fake Coin Problem</h2>
              <ul>
          <li><strong>Fake Coin Problem:</strong> Identify fake coin using fewest weighings.</li>
        </ul>
            <h2 class="section-title"> Huffman Coding</h2>
              <ul>
          <li><strong>Huffman Coding:</strong> Lossless data compression using variable-length codes based on frequencies.</li>
        </ul>
            <h2 class="section-title">Undecidability</h2>
             <ul>
          <li><strong>Undecidability:</strong> Some problems have no algorithmic solution, like the Halting Problem.</li>
        </ul>
           <h2 class="section-title"> P, NP, and Classes</h2>
             <ul>
          <li><strong>P (Polynomial Time):</strong> Problems solvable in polynomial time.</li>
          <li><strong>NP (Non-deterministic Polynomial Time):</strong> Problems verifiable in polynomial time.</li>
          <li><strong>NP-Complete:</strong> Problems in NP as hard as any problem in NP.</li>
        </ul>
      </div>
    </section>
  </div>
</body>
</html>
